<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SwitchVoiceNavi</title>
  <link rel="stylesheet" href="./styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"/>
</head>
<body>
  <header class="topbar">
    <div class="brand">SwitchVoiceNavi</div>
  </header>

  <section class="toolbar">
    <div class="search">
      <input id="addr" type="text" placeholder="住所・スポット名を入力" />
      <button id="searchBtn" class="btn">目的地検索</button>
    </div>
    <div class="actions">
      <button id="locBtn" class="btn ghost">現在地へ</button>
      <button id="startBtn" class="btn primary">案内開始</button>
      <button id="stopBtn" class="btn danger">停止</button>
    </div>
  </section>

  <div id="map" class="map"></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <script>
  // ===== Settings =====
  // TODO: replace with your Workers endpoint (no trailing slash)
  const API_BASE = "https://ors-proxy.lamb565.workers.dev";
  const PROFILE = "driving-car";
  const STEP_TRIGGER_METERS = 35;
  const OFF_ROUTE_METERS = 70;
  const VOICE_LANG_HINT = "ja";

  // ===== Utils =====
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const haversine = (a, b) => {
    const [lng1, lat1] = a, [lng2, lat2] = b;
    const dLat = toRad(lat2-lat1), dLon = toRad(lng2-lng1);
    const h = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  };
  const toXY = (lng, lat, lat0) => {
    const x = toRad(lng) * Math.cos(toRad(lat0)) * R;
    const y = toRad(lat) * R;
    return [x,y];
  };
  const pointToSegmentDistance = (p, a, b) => {
    const lat0 = (a[1]+b[1]+p[1])/3;
    const P = toXY(p[0],p[1],lat0), A = toXY(a[0],a[1],lat0), B = toXY(b[0],b[1],lat0);
    const AB = [B[0]-A[0], B[1]-A[1]], AP = [P[0]-A[0], P[1]-A[1]];
    const ab2 = AB[0]*AB[0]+AB[1]*AB[1];
    const t = ab2===0 ? 0 : Math.max(0, Math.min(1, (AP[0]*AB[0]+AP[1]*AB[1])/ab2));
    const proj = [A[0]+t*AB[0], A[1]+t*AB[1]];
    const dx=P[0]-proj[0], dy=P[1]-proj[1];
    return Math.sqrt(dx*dx+dy*dy);
  };
  const minDistanceToPolyline = (p, line) => {
    let min = Infinity;
    for (let i=1;i<line.length;i++){
      const d = pointToSegmentDistance(p, line[i-1], line[i]);
      if (d < min) min = d;
    }
    return min;
  };

  // ===== Speech (device TTS) =====
  let preferredVoice = null;
  function pickVoice() {
    const vs = speechSynthesis.getVoices();
    if (!vs || !vs.length) return null;
    const byLang = vs.find(v => (v.lang||"").toLowerCase().startsWith(VOICE_LANG_HINT));
    return byLang || null;
  }
  const speak = (text) => new Promise((resolve, reject) => {
    const u = new SpeechSynthesisUtterance(text);
    if (!preferredVoice) preferredVoice = pickVoice();
    if (preferredVoice) u.voice = preferredVoice;
    u.onend = resolve; u.onerror = reject;
    speechSynthesis.speak(u);
  });
  // Some browsers populate voices asynchronously
  window.speechSynthesis.onvoiceschanged = () => { preferredVoice = pickVoice(); };

  // ===== Map =====
  const map = new maplibregl.Map({
    container: 'map',
    style: 'https://demotiles.maplibre.org/style.json',
    center: [139.767, 35.681],
    zoom: 14
  });
  map.addControl(new maplibregl.NavigationControl());
  map.addControl(new maplibregl.AttributionControl({ compact: true }));

  let userMarker, destMarker;
  let routeCoords = [];
  let steps = []; // {text, point:[lng,lat]}
  let stepIdx = 0;
  let watchId = null;

  // floating toast status (no layout impact)
  let statusEl = null, statusTimer = null;
  function ensureStatusEl(){
    if (!statusEl) {
      statusEl = document.createElement('div');
      statusEl.id = 'status-float';
      statusEl.className = 'status-float';
      document.body.appendChild(statusEl);
    }
    return statusEl;
  }
  // setStatus(text, sticky?): sticky=true keeps it visible until next update
  function setStatus(text, sticky=false){
    const el = ensureStatusEl();
    el.textContent = text;
    el.classList.add('show');
    if (!sticky) {
      clearTimeout(statusTimer);
      statusTimer = setTimeout(()=> el.classList.remove('show'), 2000);
    }
  }

  // Add raster OSM so roads are visible
  map.on('load', () => {
    map.addSource('osm', {
      type: 'raster',
      tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: '© OpenStreetMap contributors'
    });
    map.addLayer({ id: 'osm', type: 'raster', source: 'osm' });
  });

  // ===== ORS via Workers proxy =====
  async function fetchRoute(start, goal){
    const res = await fetch(`${API_BASE}/route`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ coordinates: [start, goal] })
    });
    if (!res.ok) throw new Error("Proxy /route failed");
    return res.json();
  }
  async function geocodeORS(text){
    const res = await fetch(`${API_BASE}/geocode?text=${encodeURIComponent(text)}`);
    if (!res.ok) throw new Error("Proxy /geocode failed");
    return res.json();
  }

  function drawRouteFeature(feature){
    if (!map.getSource('route')){
      map.addSource('route', { type:'geojson', data: feature });
      map.addLayer({ id:'route', type:'line', source:'route',
        paint:{ 'line-width':5, 'line-color':'#1b6ef3' }});
    } else {
      map.getSource('route').setData(feature);
    }
    const coords = feature.geometry.coordinates;
    const bounds = coords.reduce((b,c)=>b.extend(c), new maplibregl.LngLatBounds(coords[0], coords[0]));
    map.fitBounds(bounds, { padding: 60, duration: 700 });
  }

  function buildStepsFromORS(feature){
    const seg = feature.properties?.segments?.[0];
    const list = [];
    if (!seg) return list;
    const coords = feature.geometry.coordinates;
    for (const s of (seg.steps||[])){
      const idx = s.way_points?.[1];
      const pt = (typeof idx==='number' && coords[idx]) ? coords[idx] : coords[coords.length-1];
      list.push({ text: s.instruction, point: pt });
    }
    return list;
  }

  // ===== Wake Lock (optional)
  let wakeLock = null;
  async function enableWakeLock() {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => {
        // try to reacquire when released unexpectedly
        if (document.visibilityState === 'visible') enableWakeLock().catch(()=>{});
      });
    } catch (e) {
      console.warn('WakeLock failed:', e);
    }
  }
  // call from a user gesture (e.g., on "案内開始" click)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && !wakeLock) enableWakeLock();
  });


  // ===== Nav logic =====
  function startWatching(goal){
    if (!navigator.geolocation){ speak('位置情報が使えません'); return; }
    if (watchId !== null){ navigator.geolocation.clearWatch(watchId); watchId = null; }

    watchId = navigator.geolocation.watchPosition(async pos => {
      const here = [pos.coords.longitude, pos.coords.latitude];

      if (!userMarker){
        userMarker = new maplibregl.Marker({color:'#333'}).setLngLat(here).addTo(map);
      } else {
        userMarker.setLngLat(here);
      }

      if (routeCoords.length >= 2){
        const off = minDistanceToPolyline(here, routeCoords);
        if (off > OFF_ROUTE_METERS){
          setStatus(`コース外 ${off|0}m → リルート中…`);
          try{
            const data = await fetchRoute(here, goal);
            const feat = data.features[0];
            routeCoords = feat.geometry.coordinates;
            steps = buildStepsFromORS(feat);
            stepIdx = 0;
            drawRouteFeature(feat);
            await speak('ルートを再検索しました');
          }catch(e){ console.error(e); }
          return;
        }
      }

      const next = steps[stepIdx];
      if (next){
        const d = haversine(here, next.point);
        setStatus(`次案内まで ${d|0}m`);
        if (d < STEP_TRIGGER_METERS){
          try{ await speak(next.text); }catch(e){}
          stepIdx++;
          if (stepIdx >= steps.length){ setStatus('目的地付近です'); speak('目的地付近です'); }
        }
      }
    }, err => { console.error(err); setStatus('位置情報エラー'); },
       { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
  }

  async function moveToCurrent(){
    if (!navigator.geolocation){ setStatus('Geolocation非対応'); return; }
    navigator.geolocation.getCurrentPosition(p => {
      const here = [p.coords.longitude, p.coords.latitude];
      map.setCenter(here);
      if (!userMarker) userMarker = new maplibregl.Marker({color:'#333'}).setLngLat(here).addTo(map);
      else userMarker.setLngLat(here);
      setStatus('現在地OK');
    }, () => setStatus('現在地NG'), { enableHighAccuracy:true, timeout:8000 });
  }

  // ===== UI events =====
  document.getElementById('locBtn').addEventListener('click', moveToCurrent);

  document.getElementById('searchBtn').addEventListener('click', async () => {
    const q = document.getElementById('addr').value.trim();
    if (!q){ setStatus('住所・スポット名を入力してね'); return; }
    try{
      setStatus('検索中…');
      const data = await geocodeORS(q);
      const f = data.features?.[0];
      if (!f) throw new Error('No geocode result');
      const goal = f.geometry.coordinates; // [lng,lat]
      const label = f.properties?.label 
                 || f.properties?.display_name 
                 || f.properties?.name 
                 || '目的地';
      if (!destMarker) destMarker = new maplibregl.Marker({color:'#e63946'}).setLngLat(goal).addTo(map);
      else destMarker.setLngLat(goal);
      const start = userMarker ? userMarker.getLngLat().toArray() : map.getCenter().toArray();
      const route = await fetchRoute(start, goal);
      const feat = route.features[0];
      routeCoords = feat.geometry.coordinates;
      steps = buildStepsFromORS(feat);
      stepIdx = 0;
      drawRouteFeature(feat);
      setStatus(`目的地: ${label}`);
    }catch(e){
      console.error(e);
      setStatus('検索またはルート取得に失敗');
    }
  });

  document.getElementById('addr').addEventListener('keydown', (e)=>{
    if(e.key==='Enter') document.getElementById('searchBtn').click();
  });

  document.getElementById('startBtn').addEventListener('click', async () => {
    try{
      preferredVoice = pickVoice();
      await speak('ナビを開始します');
      await enableWakeLock();
      const goal = destMarker ? destMarker.getLngLat().toArray() : null;
      if (!goal){ setStatus('先に目的地を設定してね'); return; }
      startWatching(goal);
      setStatus('現在地追従中');
    }catch(e){ console.error(e); }
  });

  document.getElementById('stopBtn').addEventListener('click', () => {
    if (watchId !== null){ navigator.geolocation.clearWatch(watchId); watchId = null; }
    speechSynthesis.cancel();
    setStatus('停止しました');
  });

  // Bootstrap: try initial position
  if (navigator.geolocation){
    navigator.geolocation.getCurrentPosition(p=>{
      const here=[p.coords.longitude,p.coords.latitude];
      map.setCenter(here);
      userMarker = new maplibregl.Marker({color:'#333'}).setLngLat(here).addTo(map);
      setStatus('現在地OK：住所検索→案内開始で音声ナビ');
    }, ()=>setStatus('現在地を取得できませんでした'), { enableHighAccuracy:true, timeout:8000 });
  } else {
    setStatus('Geolocation非対応ブラウザ');
  }
  </script>
</body>
</html>
