<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SwitchVoiceNavi — ブラウザで動く音声ナビ</title>
  <meta name="description" content="MapLibre × OpenRouteService。二段階音声案内、リルート、HUD、料金回避に対応したブラウザナビ。">
  <meta name="theme-color" content="#0f172a">

  <!-- PWA -->
  <link rel="manifest" href="./manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- MapLibre CSS（ローカル優先。vendor/maplibre-gl.css を同梱） -->
  <link href="./vendor/maplibre-gl.css" rel="stylesheet">

  <style>
    :root{
      --container:1100px;
      --ink:#0f172a; --muted:#64748b; --brand:#1b6ef3;
      --map-top:180px;     /* header+toolbar 分 */
      --map-bottom:140px;  /* HUD 分 */
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;height:100%}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;color:var(--ink);background:#f8fafc}
    a{color:#1b6ef3;text-decoration:none} a:hover{text-decoration:underline}

    .header{position:sticky;top:0;z-index:50;background:#fff;border-bottom:1px solid #e2e8f0}
    .header-inner{max-width:var(--container);margin:0 auto;height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 16px}
    .brand{font-weight:700}
    .nav a{margin-left:16px;color:#0f172a}

    .toolbar{max-width:var(--container);margin:0 auto;padding:10px 16px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;transition:all .25s ease}
    .toolbar input[type="text"]{flex:1;min-width:220px;padding:10px;border:1px solid #e2e8f0;border-radius:10px;background:#fff}
    .btn{display:inline-block;padding:10px 14px;border-radius:999px;border:1px solid #e2e8f0;background:#fff;color:#0f172a;font-weight:600}
    .btn.primary{background:#1b6ef3;border-color:transparent;color:#fff}
    .btn:disabled{opacity:.5;pointer-events:none}

    /* map viewport uses CSS vars for dynamic top/bottom gaps */
    #map{position:fixed;inset:var(--map-top) 0 var(--map-bottom) 0}

    .hud{position:fixed;left:0;right:0;bottom:0;background:rgba(255,255,255,.96);border-top:1px solid #e2e8f0}
    .hud-inner{max-width:var(--container);margin:0 auto;display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 16px}
    .stat{display:flex;gap:6px;align-items:baseline}.stat b{font-size:20px}

    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:108px;background:#111827;color:#fff;padding:10px 14px;border-radius:10px;opacity:.96;display:none}
    .card{position:fixed;left:50%;transform:translateX(-50%);top:66px;background:#fff;border:1px solid #e2e8f0;border-radius:12px;box-shadow:0 10px 30px rgba(15,23,42,.08);display:none;min-width:280px;max-width:calc(100vw - 24px)}
    .card header{padding:10px 14px;border-bottom:1px solid #e2e8f0;font-weight:700}
    .card .body{padding:10px 14px}
    .card .item{padding:8px;border-radius:8px;cursor:pointer}
    .card .item:hover{background:#f1f5f9}

    /* ======= ナビ中のコンパクト表示 ======= */
    body.navigating { --map-top:66px; }                /* toolbarを畳むので map top を縮める */
    body.navigating .toolbar { height:0; padding:0; overflow:hidden; border:0; }
    body.navigating .nav { display:none; }             /* 右上リンクも隠す */

    /* 右上：停止ボタン（ナビ中のみ固定表示・赤） */
    #btnStop{
      position:fixed; top:10px; right:12px; z-index:60; display:none;
      background:#ef4444; color:#fff; border-color:transparent;
    }
    body.navigating #btnStop{ display:inline-block; }
    body:not(.navigating) #btnStop{ position:static; display:inline-block; background:#fff; color:#0f172a; border:1px solid #e2e8f0; }

    /* 右上：追従トグル（停止の左。ナビ中のみ表示） */
    #btnFollowToggle{
      position:fixed; top:10px; right:112px; z-index:60; display:none;
      background:#fff; color:#0f172a; border:1px solid #e2e8f0;
    }
    body.navigating #btnFollowToggle{ display:inline-block; }
    body:not(.navigating) #btnFollowToggle{ display:none; }

    @media (max-width:680px){
      :root{ --map-top:206px; --map-bottom:160px; }
      body.navigating{ --map-top:66px; }
      .hud-inner{flex-wrap:wrap}
      #btnFollowToggle{ right:108px; }
    }
  </style>

  <!-- MapLibre ローダ（ローカル → jsDelivr → unpkg） -->
  <script>
    (function(){
      function loadScript(src, next){var s=document.createElement('script');s.src=src;s.async=false;s.onload=next;s.onerror=next;document.head.appendChild(s);}
      function loadCSS(href){var l=document.createElement('link');l.rel='stylesheet';l.href=href;document.head.appendChild(l);}
      function ensureMaplibre(cb){
        if (window.maplibregl) return cb();
        loadScript('./vendor/maplibre-gl.js', function(){
          if (window.maplibregl) return cb();
          loadScript('https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.js', function(){
            if (!document.querySelector('link[href*="maplibre-gl.css"]')){
              loadCSS('https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.css');
            }
            if (window.maplibregl) return cb();
            loadScript('https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js', function(){
              if (!document.querySelector('link[href*="maplibre-gl.css"]')){
                loadCSS('https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css');
              }
              cb();
            });
          });
        });
      }
      window.__boot = function(start){ ensureMaplibre(start); };
    })();
  </script>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <div class="brand">SwitchVoiceNavi</div>
      <nav class="nav">
        <a href="https://lamb5656.github.io/navi-app/browser-navi/howto.html" rel="noopener noreferrer">設定方法</a>
      </nav>
    </div>
  </header>

  <div class="toolbar">
    <input id="addr" type="text" placeholder="目的地を検索（例：名古屋駅）">
    <button id="btnSearch" class="btn">検索</button>
    <label><input id="avoidTolls" type="checkbox" checked> 有料道路回避</label>
    <button id="btnStart" class="btn primary">ナビ開始</button>

    <!-- 停止＆追従トグル：通常はツールバー内（見えない）。ナビ中は右上固定へ -->
    <button id="btnFollowToggle" class="btn" type="button">進行方向</button>
    <button id="btnStop" class="btn" disabled>停止</button>
  </div>

  <div id="map" aria-label="map"></div>

  <div class="hud" role="status" aria-live="polite">
    <div class="hud-inner">
      <div class="stat">残距離 <b id="remainKm">–</b> km</div>
      <div class="stat">到着予想 <b id="eta">–:–</b></div>
      <div class="stat">状態 <span id="status">待機中</span></div>
      <!-- ※ 要望により、未開始時は追従UIは出さないためHUDからも削除 -->
    </div>
  </div>

  <div id="toast" class="toast"></div>
  <div id="searchCard" class="card" aria-modal="true" role="dialog">
    <header>検索候補</header>
    <div class="body" id="searchList"></div>
  </div>

<script>
/* ==== PWA Service Worker ==== */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(console.error);
}

/* ==== Config ==== */
const API_BASE = "https://ors-proxy.lamb565.workers.dev";
const TILE_URL = "https://tile.openstreetmap.org/{z}/{x}/{y}.png";

/* ==== Map / markers ==== */
let map, routeLayerId = "route-line";
let posMarker, goalMarker;
let mapReady = false;
const markerQueue = []; // [[lng,lat], 'pos'|'goal']

// follow & bearing control
let followMode = 'course';    // 'course' | 'north' （デフォルト：進行方向）
let autoFollow = true;
let restoreTimer = null;
let lastHeading = 0;          // deg
let lastPosForCourse = null;  // 案内中の移動ベクトル用

const mapStyle = {
  "version": 8,
  "sources": { "osm": { "type": "raster", "tiles": [TILE_URL], "tileSize": 256, "attribution": "© OpenStreetMap contributors" } },
  "layers": [
    {"id":"bg","type":"background","paint":{"background-color":"#dfe9f6"}},
    {"id":"osm","type":"raster","source":"osm"}
  ]
};

function initMap() {
  if (!window.maplibregl){ alert("Map library failed to load. Please reload."); return; }
  map = new maplibregl.Map({ container:"map", style:mapStyle, center:[139.767,35.681], zoom:12, attributionControl:true });
  map.addControl(new maplibregl.NavigationControl(), "top-left");
  map.on('load', () => {
    mapReady = true;
    while (markerQueue.length){
      const [lngLat, kind] = markerQueue.shift();
      if (kind==='pos') _setMarkerImmediate(lngLat);
      else _setGoalImmediate(lngLat);
    }
  });

  // ユーザー操作 → 追従一時停止 → 5秒後に自動復帰
  function pauseFollow(){ autoFollow = false; if (restoreTimer) clearTimeout(restoreTimer); }
  map.on('dragstart', pauseFollow);
  map.on('rotatestart', pauseFollow);
  map.on('pitchstart', pauseFollow);
  function scheduleRestore(){ if (restoreTimer) clearTimeout(restoreTimer); restoreTimer = setTimeout(()=>{ autoFollow = true; }, 5000); }
  map.on('dragend', scheduleRestore);
  map.on('rotateend', scheduleRestore);
  map.on('pitchend', scheduleRestore);
}

function _setMarkerImmediate(lngLat){
  if (!posMarker){ posMarker = new maplibregl.Marker({color:"#16a34a"}).setLngLat(lngLat).addTo(map); }
  else { posMarker.setLngLat(lngLat); }
}
function _setGoalImmediate(lngLat){
  if (!goalMarker){ goalMarker = new maplibregl.Marker({color:"#ef4444"}).setLngLat(lngLat).addTo(map); }
  else { goalMarker.setLngLat(lngLat); }
}

function setMarker(lngLat){
  if (!window.maplibregl || !map || !mapReady){ markerQueue.push([lngLat,'pos']); return; }
  _setMarkerImmediate(lngLat);
}
function setGoal(lngLat){
  if (!window.maplibregl || !map || !mapReady){ markerQueue.push([lngLat,'goal']); return; }
  _setGoalImmediate(lngLat);
}

function updateMapView(){
  if (!mapReady || !here) return;
  // bearing（進行方向 or 北固定）
  let bearing = (followMode === 'course') ? (lastHeading || 0) : 0;
  if (autoFollow){
    map.easeTo({ center: here, bearing, duration: 300 });
  }
}

/* ==== Helpers ==== */
function toast(msg, ms=1800){ const el=document.getElementById("toast"); el.textContent=msg; el.style.display="block"; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display="none", ms); }
function hav(a,b){ const R=6371000, toRad=x=>x*Math.PI/180; const dLat=toRad(b[1]-a[1]), dLng=toRad(b[0]-a[0]), la1=toRad(a[1]), la2=toRad(b[1]); const A=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(la2)*Math.sin(dLng/2)**2; return 2*R*Math.asin(Math.sqrt(A)); }
function nearestIndex(p, line){ let mi=0, md=Infinity; for(let i=0;i<line.length;i++){ const d=hav(p,line[i]); if(d<md){md=d;mi=i;} } return mi; }
function pointToSegmentDistance(p,a,b){
  const toXY=(ll)=>[ll[0]*111320*Math.cos(ll[1]*Math.PI/180), ll[1]*110540];
  const P=toXY(p), A=toXY(a), B=toXY(b), AB=[B[0]-A[0],B[1]-A[1]], AP=[P[0]-A[0],P[1]-A[1]];
  const ab2 = AB[0]*AB[0]+AB[1]*AB[1] || 1;
  let t=(AP[0]*AB[0]+AP[1]*AB[1])/ab2; t=Math.max(0,Math.min(1,t));
  const X=[A[0]+AB[0]*t,A[1]+AB[1]*t]; return Math.hypot(P[0]-X[0], P[1]-X[1]);
}
function minDistanceToPolyline(point, line){ let md=Infinity; for(let i=1;i<line.length;i++){ const d=pointToSegmentDistance(point,line[i-1],line[i]); if(d<md) md=d; } return md; }
function bboxOfCoords(coords){
  let minLng=Infinity,minLat=Infinity,maxLng=-Infinity,maxLat=-Infinity;
  for(const [lng,lat] of coords){ if(lng<minLng)minLng=lng; if(lat<minLat)minLat=lat; if(lng>maxLng)maxLng=lng; if(lat>maxLat)maxLat=lat; }
  return [[minLng,minLat],[maxLng,maxLat]];
}

/* ==== Geocoding UI ==== */
const addr=document.getElementById("addr");
const card=document.getElementById("searchCard");
const list=document.getElementById("searchList");
document.getElementById("btnSearch").addEventListener("click", onSearch);

async function onSearch(){
  const q=addr.value.trim(); if(!q) return;
  try{
    const res=await fetch(`${API_BASE}/geocode?text=${encodeURIComponent(q)}`,{credentials:"omit"});
    const data=await res.json();
    list.innerHTML="";
    (data?.features||[]).slice(0,8).forEach(f=>{
      const c=f.geometry.coordinates;
      const name=f.properties?.label||f.properties?.name||`${c[1]},${c[0]}`;
      const div=document.createElement("div");
      div.className="item"; div.textContent=name;
      div.addEventListener("click", ()=>{ setGoal(c); goal=c; if(mapReady) map.easeTo({center:c,zoom:16}); card.style.display="none"; });
      list.appendChild(div);
    });
    card.style.display="block";
  }catch(e){ console.error(e); toast("検索に失敗しました"); }
}

/* ==== Routing & Guidance ==== */
let here=null, goal=null, routeCoords=[], steps=[];
let watchId=null, wakeLock=null;
let stepPreviewed=new Set();

// Debounced TTS
let __lastSpeechAt=0;
const MIN_SPEECH_INTERVAL_MS=3500;
function speakLine(text){
  const now=Date.now();
  if(now-__lastSpeechAt<MIN_SPEECH_INTERVAL_MS) return;
  __lastSpeechAt=now;
  try{ const u=new SpeechSynthesisUtterance(text); u.rate=1.0; u.pitch=1.0; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); }catch(e){ console.warn("TTS failed",e); }
}

// Preview dedupe across re-routes
const PREVIEW_M=300, EXECUTE_M=40, PREVIEW_COOLDOWN_MS=45000;
const previewHistory=new Map();
function stepPreviewKey(step){ const wp=step?.way_points?.[1]??-1; const ins=(step?.instruction||"").trim(); return `${wp}:${ins}`; }

// Re-route hysteresis
let offRouteCount=0, lastRerouteAt=0;
const OFF_ROUTE_METERS=90, OFF_ROUTE_HYST_COUNT=3, REROUTE_COOLDOWN_MS=15000;

// Arrival handling
let arrivalPreviewed = false; // 50mの一度きり

function setStatus(t){ document.getElementById("status").textContent=t; }

async function fetchRoute(startLngLat, goalLngLat, opt={}){
  const body=JSON.stringify({coordinates:[startLngLat,goalLngLat], avoidTolls:!!opt.avoidTolls});
  const res=await fetch(`${API_BASE}/route`,{method:"POST",headers:{"Content-Type":"application/json"},body});
  if(!res.ok) throw new Error("route error");
  return res.json();
}

function drawRouteFeature(feature){
  if(!mapReady) return;
  const geo={type:"FeatureCollection",features:[feature]};
  if(map.getSource("route")){ map.getSource("route").setData(geo); }
  else{
    map.addSource("route",{type:"geojson",data:geo});
    map.addLayer({id:routeLayerId,type:"line",source:"route",paint:{"line-color":"#2563eb","line-width":5,"line-opacity":0.9}});
  }
  const coords=feature.geometry.coordinates;
  const bbox=bboxOfCoords(coords);
  map.fitBounds(bbox,{padding:50,maxZoom:16,duration:600});
}

function setupGuidance(feature){
  routeCoords=feature.geometry.coordinates;
  const seg=feature.properties?.segments?.[0]||{};
  steps=seg.steps||[];
  stepPreviewed=new Set();
  arrivalPreviewed=false;
  drawRouteFeature(feature);
  if(here&&mapReady) map.easeTo({center:here,zoom:15,duration:400});
}

async function startNav(){
  if(!goal){ toast("まず目的地を検索・選択してください"); return; }
  try{
    if(!here){ toast("現在地の取得を待っています…"); }
    const avoidTolls=document.getElementById("avoidTolls").checked;
    const data=await fetchRoute(here||goal, goal, {avoidTolls});
    const feat=data.features[0];
    setupGuidance(feat);
    setStatus("案内中");
    document.getElementById("btnStart").disabled=true;
    document.getElementById("btnStop").disabled=false;

    // 追従トグル：開始時はデフォルト「進行方向」
    followMode = 'course';
    updateFollowToggleLabel();

    // ナビ中モード
    document.body.classList.add('navigating');
    card.style.display = "none";
    autoFollow = true;

    if("wakeLock" in navigator && navigator.wakeLock?.request){ try{ wakeLock=await navigator.wakeLock.request("screen"); }catch{} }
    beginWatch();
    speakLine("案内を開始します");
  }catch(e){ console.error(e); toast("ルート取得に失敗しました"); }
}

function stopNav(){
  if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; }
  if(wakeLock){ try{ wakeLock.release(); }catch{} wakeLock=null; }
  setStatus("停止中");
  document.getElementById("btnStart").disabled=false;
  document.getElementById("btnStop").disabled=true;

  // 復元
  document.body.classList.remove('navigating');

  speakLine("案内を停止しました");
}

function updateHUD(remainMeters, etaSec){
  document.getElementById("remainKm").textContent = isFinite(remainMeters) ? (remainMeters/1000).toFixed(1) : "–";
  if(isFinite(etaSec)){ const d=new Date(Date.now()+etaSec*1000); const hh=String(d.getHours()).padStart(2,"0"); const mm=String(d.getMinutes()).padStart(2,"0"); document.getElementById("eta").textContent=`${hh}:${mm}`; }
  else { document.getElementById("eta").textContent="–:–"; }
}

function estimateRemainMetersAndETA(point){
  if(!routeCoords.length) return {meters:NaN, eta:NaN};
  const idx=nearestIndex(point, routeCoords);
  let meters=hav(point, routeCoords[idx]);
  for(let i=idx;i<routeCoords.length-1;i++) meters+=hav(routeCoords[i], routeCoords[i+1]);
  const speed=11.1; return {meters, eta:meters/speed};
}

function computeCourseFromPositions(prev, curr){
  if (!prev || !curr) return null;
  const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
  const dLng = toRad(curr[0]-prev[0]);
  const y = Math.sin(dLng) * Math.cos(toRad(curr[1]));
  const x = Math.cos(toRad(prev[1]))*Math.sin(toRad(curr[1])) - Math.sin(toRad(prev[1]))*Math.cos(toRad(curr[1]))*Math.cos(dLng);
  let brng = toDeg(Math.atan2(y, x));
  brng = (brng + 360) % 360;
  return brng;
}

async function beginWatch(){
  if(watchId) navigator.geolocation.clearWatch(watchId);
  watchId = navigator.geolocation.watchPosition(async (pos)=>{
    const prev = here;
    here=[pos.coords.longitude,pos.coords.latitude];
    setMarker(here);

    // heading 取得（GPS優先→移動ベクトル）
    if (typeof pos.coords.heading === 'number' && !Number.isNaN(pos.coords.heading)) {
      lastHeading = pos.coords.heading; // 0..360 (deg, 0=north)
    } else {
      const c = computeCourseFromPositions(lastPosForCourse || prev, here);
      if (c != null) lastHeading = c;
      lastPosForCourse = here;
    }
    updateMapView();

    if (!routeCoords.length){ if(mapReady) map.easeTo({center:here,zoom:15}); return; }

    const est=estimateRemainMetersAndETA(here);
    updateHUD(est.meters, est.eta);

    // 到着処理：50m 予告 → 0–20m 到着
    if (!arrivalPreviewed && est.meters <= 50){
      arrivalPreviewed = true;
      speakLine("まもなく目的地に到着します");
    }
    if (est.meters <= 20){
      speakLine("目的地に到着しました");
      toast("到着しました。おつかれさまでした");
      stopNav();
      return;
    }

    // 次ステップ案内
    const idx=nearestIndex(here, routeCoords);
    let nextStepIndex=-1;
    for (let i=0;i<steps.length;i++){
      const wp=steps[i]?.way_points?.[1];
      if (typeof wp==="number" && wp>idx){ nextStepIndex=i; break; }
    }
    if (nextStepIndex>=0){
      const step=steps[nextStepIndex], wp=step.way_points[1];
      const remainToNext=hav(here, routeCoords[wp]);
      if(!stepPreviewed.has(nextStepIndex) && remainToNext<=300){
        const key=(()=>{ const w=step?.way_points?.[1]??-1; const ins=(step?.instruction||"").trim(); return `${w}:${ins}`; })();
        const now=Date.now(); const last=previewHistory.get(key)||0;
        if(now-last>=45000){ stepPreviewed.add(nextStepIndex); previewHistory.set(key, now); speakLine(`300メートル先、${step.instruction||"進行方向です"}`); }
      }
      if(remainToNext<=40){ speakLine(step.instruction||"その先です"); }
    }

    // オフルート→ヒステリシス→リルート
    const off=minDistanceToPolyline(here, routeCoords);
    if(off>90){ offRouteCount++; } else { offRouteCount=0; }
    const now=Date.now();
    if(offRouteCount>=3 && (now-lastRerouteAt)>=15000){
      lastRerouteAt=now; setStatus(`コース外 ${off|0}m → リルート中…`);
      try{
        const avoidTolls=document.getElementById("avoidTolls").checked;
        const data=await fetchRoute(here, goal, {avoidTolls});
        const feat=data.features[0]; setupGuidance(feat); speakLine("ルートを再検索しました");
      }catch(e){ console.error(e); }
      return;
    }
  }, (err)=>{ console.error(err); toast("現在地の取得に失敗しました"); }, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
}

/* ==== 追従トグル ==== */
const btnFollowToggle = document.getElementById('btnFollowToggle');
function updateFollowToggleLabel(){
  btnFollowToggle.textContent = (followMode === 'course') ? '進行方向' : '北固定';
}
btnFollowToggle.addEventListener('click', ()=>{
  followMode = (followMode === 'course') ? 'north' : 'course';
  updateFollowToggleLabel();
  autoFollow = true;      // 切替時は即追従
  updateMapView();
});

/* ==== Events ==== */
document.getElementById("btnSearch").addEventListener("click", onSearch);
document.getElementById("btnStart").addEventListener("click", startNav);
document.getElementById("btnStop").addEventListener("click", stopNav);

/* ==== Boot ==== */
window.__boot(function(){
  initMap();
  navigator.geolocation.getCurrentPosition((pos)=>{
    here=[pos.coords.longitude,pos.coords.latitude];
    setMarker(here);
    if(mapReady) map.easeTo({center:here,zoom:15});
  }, ()=>{}, {enableHighAccuracy:true, timeout:5000});
});
</script>
</body>
</html>
